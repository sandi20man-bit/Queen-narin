{"file_contents":{"main.py":{"content":"import os\nimport pytz\nimport random\nimport html\nimport tempfile\nimport requests\nimport io\nimport aiohttp\nimport asyncio\nfrom datetime import datetime, time\nfrom dotenv import load_dotenv\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes\n\n# In-memory storage untuk video file_id (untuk random video)\nvideo_file_ids = []\n\n# Auto-delete helper function\nasync def auto_delete_message(context: ContextTypes.DEFAULT_TYPE, chat_id, message_id, delay_seconds=7):\n    \"\"\"Hapus pesan otomatis setelah delay tertentu (default 7 detik)\"\"\"\n    try:\n        await asyncio.sleep(delay_seconds)\n        await context.bot.delete_message(chat_id=chat_id, message_id=message_id)\n        print(f\"üóëÔ∏è Auto-deleted message {message_id} from chat {chat_id}\")\n    except Exception as e:\n        # Pesan mungkin sudah dihapus atau tidak bisa dihapus\n        print(f\"‚ö†Ô∏è Could not auto-delete message {message_id}: {e}\")\n\nasync def schedule_message_deletion(context: ContextTypes.DEFAULT_TYPE, message, delay_seconds=7):\n    \"\"\"Schedule pesan untuk dihapus dengan delay custom (default 7 detik)\"\"\"\n    if message and message.message_id and message.chat:\n        # Jalankan auto-delete dalam background task\n        asyncio.create_task(auto_delete_message(context, message.chat.id, message.message_id, delay_seconds))\n        print(f\"‚è∞ Scheduled deletion for message {message.message_id} in {delay_seconds} seconds\")\n\n# Centralized ephemeral messaging functions\nasync def send_ephemeral_text(update: Update, context: ContextTypes.DEFAULT_TYPE, text, parse_mode='HTML', reply_markup=None, is_reply=True):\n    \"\"\"Send ephemeral text message that auto-deletes in 7 seconds\"\"\"\n    try:\n        sent_message = None\n        if is_reply and update.message:\n            sent_message = await update.message.reply_text(text, parse_mode=parse_mode, reply_markup=reply_markup)\n        elif update.callback_query and update.callback_query.message:\n            sent_message = await context.bot.send_message(\n                chat_id=update.callback_query.message.chat.id,\n                text=text,\n                parse_mode=parse_mode,\n                reply_markup=reply_markup\n            )\n        elif update.effective_chat:\n            sent_message = await context.bot.send_message(\n                chat_id=update.effective_chat.id,\n                text=text,\n                parse_mode=parse_mode,\n                reply_markup=reply_markup\n            )\n        \n        # Schedule for auto-delete\n        if sent_message:\n            await schedule_message_deletion(context, sent_message)\n            print(f\"‚úÖ Ephemeral text sent: {text[:50]}...\")\n        \n        return sent_message\n        \n    except Exception as e:\n        print(f\"‚ùå Error sending ephemeral text: {e}\")\n        return None\n\nasync def send_ephemeral_voice(update: Update, context: ContextTypes.DEFAULT_TYPE, text):\n    \"\"\"Send ephemeral voice message that auto-deletes in 7 seconds\"\"\"\n    voice_file = None\n    try:\n        # Generate voice file dengan ElevenLabs\n        voice_file = await create_elevenlabs_voice(text)\n        \n        if voice_file and update.effective_chat:\n            # Send \"upload_voice\" action\n            await context.bot.send_chat_action(\n                chat_id=update.effective_chat.id, \n                action=\"upload_voice\"\n            )\n            \n            # Kirim voice message dan capture response\n            with open(voice_file, 'rb') as voice:\n                sent_voice = await context.bot.send_voice(\n                    chat_id=update.effective_chat.id,\n                    voice=voice\n                )\n            \n            # Schedule voice message for auto-delete (20 detik untuk voice)\n            if sent_voice:\n                await schedule_message_deletion(context, sent_voice, delay_seconds=20)\n                print(f\"‚úÖ Ephemeral voice sent and scheduled for deletion: {text[:50]}...\")\n            \n            return sent_voice\n        else:\n            print(\"‚ùå Gagal membuat ephemeral voice message\")\n            return None\n            \n    except Exception as e:\n        print(f\"‚ùå Error sending ephemeral voice: {e}\")\n        return None\n    finally:\n        # Cleanup temporary file\n        if voice_file and os.path.exists(voice_file):\n            try:\n                os.unlink(voice_file)\n            except:\n                pass\n\nasync def send_ephemeral_voice_with_fallback(update: Update, context: ContextTypes.DEFAULT_TYPE, text, fallback_text=None):\n    \"\"\"Send ephemeral voice with text fallback - both auto-delete\"\"\"\n    if not fallback_text:\n        fallback_text = text\n    \n    # Try to send ephemeral voice first\n    voice_message = await send_ephemeral_voice(update, context, text)\n    \n    # If voice fails, send ephemeral text fallback\n    if not voice_message:\n        print(\"üîÑ Voice failed, sending ephemeral text fallback\")\n        await send_ephemeral_text(update, context, fallback_text)\n        return False\n    \n    return True\n\n# ElevenLabs configuration\nELEVENLABS_API_KEY = None\nELEVENLABS_VOICE_ID = \"EXAVITQu4vr4xnSDxMaL\"  # Bella - suara wanita natural\n\ndef init_elevenlabs():\n    \"\"\"Initialize ElevenLabs API dengan konfigurasi suara wanita\"\"\"\n    global ELEVENLABS_API_KEY\n    \n    if not ELEVENLABS_API_KEY or ELEVENLABS_API_KEY == \"your_elevenlabs_api_key_here\":\n        print(\"‚ö†Ô∏è ElevenLabs API key belum diset, voice response tidak tersedia\")\n        print(\"üí° Edit file .aldy dan isi ELEVENLABS_API_KEY untuk aktifkan fitur suara\")\n        return False\n    \n    try:\n        # Test API key dengan request sederhana\n        url = \"https://api.elevenlabs.io/v1/voices\"\n        headers = {\"xi-api-key\": ELEVENLABS_API_KEY}\n        response = requests.get(url, headers=headers, timeout=5)\n        \n        if response.status_code == 200:\n            print(f\"‚úÖ ElevenLabs API berhasil diinisialisasi dengan suara wanita {ELEVENLABS_VOICE_ID}\")\n            return True\n        else:\n            print(f\"‚ùå ElevenLabs API key tidak valid: {response.status_code}\")\n            return False\n            \n    except Exception as e:\n        print(f\"‚ùå Error inisialisasi ElevenLabs: {e}\")\n        return False\n\nasync def check_elevenlabs_quota():\n    \"\"\"Check ElevenLabs API quota dan sisa credit\"\"\"\n    global ELEVENLABS_API_KEY\n    \n    if not ELEVENLABS_API_KEY or ELEVENLABS_API_KEY == \"your_elevenlabs_api_key_here\":\n        return None\n    \n    try:\n        url = \"https://api.elevenlabs.io/v1/user/subscription\"\n        headers = {\"xi-api-key\": ELEVENLABS_API_KEY}\n        \n        async with aiohttp.ClientSession() as session:\n            async with session.get(url, headers=headers, timeout=aiohttp.ClientTimeout(total=10)) as response:\n                if response.status == 200:\n                    data = await response.json()\n                    \n                    used_chars = data.get('character_count', 0)\n                    total_chars = data.get('character_limit', 0)\n                    remaining_chars = total_chars - used_chars\n                    tier = data.get('tier', 'Unknown')\n                    reset_unix = data.get('next_character_count_reset_unix', 0)\n                    \n                    # Convert unix timestamp to readable date\n                    if reset_unix:\n                        reset_date = datetime.fromtimestamp(reset_unix, pytz.timezone(TIMEZONE))\n                        reset_str = reset_date.strftime(\"%d/%m/%Y %H:%M\")\n                    else:\n                        reset_str = \"Unknown\"\n                    \n                    return {\n                        'used': used_chars,\n                        'total': total_chars,\n                        'remaining': remaining_chars,\n                        'tier': tier,\n                        'reset_date': reset_str,\n                        'percentage_used': round((used_chars / total_chars * 100), 1) if total_chars > 0 else 0\n                    }\n                else:\n                    error_text = await response.text()\n                    print(f\"‚ùå ElevenLabs quota check error: {response.status} - {error_text}\")\n                    return None\n                    \n    except Exception as e:\n        print(f\"‚ùå Error checking ElevenLabs quota: {e}\")\n        return None\n\nasync def create_elevenlabs_voice(text):\n    \"\"\"Convert text menjadi voice menggunakan ElevenLabs API (suara wanita) - async version\"\"\"\n    global ELEVENLABS_API_KEY, ELEVENLABS_VOICE_ID\n    \n    if not ELEVENLABS_API_KEY or ELEVENLABS_API_KEY == \"your_elevenlabs_api_key_here\":\n        print(\"‚ùå ElevenLabs API key belum diset\")\n        return None\n    \n    try:\n        url = f\"https://api.elevenlabs.io/v1/text-to-speech/{ELEVENLABS_VOICE_ID}\"\n        headers = {\n            \"Accept\": \"audio/mpeg\",\n            \"Content-Type\": \"application/json\",\n            \"xi-api-key\": ELEVENLABS_API_KEY\n        }\n        \n        data = {\n            \"text\": text,\n            \"model_id\": \"eleven_multilingual_v2\",\n            \"voice_settings\": {\n                \"stability\": 0.75,\n                \"similarity_boost\": 0.75,\n                \"style\": 0.5,\n                \"use_speaker_boost\": True\n            }\n        }\n        \n        async with aiohttp.ClientSession() as session:\n            async with session.post(url, json=data, headers=headers, timeout=aiohttp.ClientTimeout(total=30)) as response:\n                if response.status == 200:\n                    # Buat temporary file untuk voice\n                    content = await response.read()\n                    with tempfile.NamedTemporaryFile(suffix='.mp3', delete=False) as temp_file:\n                        temp_file.write(content)\n                        return temp_file.name\n                else:\n                    error_text = await response.text()\n                    print(f\"‚ùå ElevenLabs API error: {response.status} - {error_text}\")\n                    return None\n            \n    except Exception as e:\n        print(f\"‚ùå Error membuat voice dengan ElevenLabs: {e}\")\n        return None\n\nasync def send_voice_response(update: Update, context: ContextTypes.DEFAULT_TYPE, text, caption=None):\n    \"\"\"Helper function untuk mengirim voice message dengan ElevenLabs - FIXED: now captures and schedules voice for auto-delete\"\"\"\n    voice_file = None\n    try:\n        # Generate voice file dengan ElevenLabs (now async)\n        voice_file = await create_elevenlabs_voice(text)\n        \n        if voice_file:\n            # Send \"upload_voice\" action\n            await context.bot.send_chat_action(\n                chat_id=update.effective_chat.id, \n                action=\"upload_voice\"\n            )\n            \n            # Kirim voice message dan capture response untuk auto-delete\n            with open(voice_file, 'rb') as voice:\n                sent_voice = await context.bot.send_voice(\n                    chat_id=update.effective_chat.id,\n                    voice=voice\n                )\n            \n            # FIXED: Schedule voice message for auto-deletion (20 detik untuk voice)\n            if sent_voice:\n                await schedule_message_deletion(context, sent_voice, delay_seconds=20)\n                print(f\"‚úÖ Voice message sent and scheduled for deletion: {text[:50]}...\")\n            \n            return True\n        else:\n            print(\"‚ùå Gagal membuat voice message\")\n            return False\n            \n    except Exception as e:\n        print(f\"‚ùå Error mengirim voice message: {e}\")\n        return False\n    finally:\n        # Cleanup temporary file\n        if voice_file and os.path.exists(voice_file):\n            try:\n                os.unlink(voice_file)\n            except:\n                pass\n\n\ndef load_config():\n    \"\"\"\n    Fungsi untuk memuat konfigurasi dari file .aldy\n    Jika file .aldy tidak ada, akan mencoba .env, lalu environment variables\n    \"\"\"\n    # Coba load dari file .aldy terlebih dahulu\n    if os.path.exists('.aldy'):\n        load_dotenv('.aldy')\n        print(\"‚úÖ Konfigurasi dimuat dari file .aldy\")\n    elif os.path.exists('.env'):\n        load_dotenv('.env')\n        print(\"‚úÖ Konfigurasi dimuat dari file .env\")\n    else:\n        print(\"‚ÑπÔ∏è File konfigurasi tidak ditemukan, menggunakan environment variables\")\n    \n    # Ambil konfigurasi dari environment variables\n    bot_token = os.getenv(\"BOT_TOKEN\")\n    chat_id_str = os.getenv(\"CHAT_ID\")\n    timezone = os.getenv(\"TIMEZONE\", \"Asia/Jakarta\")\n    elevenlabs_key = os.getenv(\"ELEVENLABS_API_KEY\")\n    \n    # Validasi CHAT_ID - bisa berupa angka atau username channel (@channelname)\n    chat_id = None\n    if chat_id_str:\n        if chat_id_str.startswith('@'):\n            # Jika format username channel/grup\n            chat_id = chat_id_str\n            print(f\"‚úÖ Menggunakan channel username: {chat_id_str}\")\n        else:\n            # Jika format angka ID\n            try:\n                chat_id = int(chat_id_str)\n                print(f\"‚úÖ Menggunakan chat ID: {chat_id}\")\n            except ValueError:\n                print(f\"‚ùå CHAT_ID tidak valid: {chat_id_str}\")\n    \n    # CHAT_ID wajib diisi untuk keamanan\n    if not chat_id:\n        print(\"‚ùå CHAT_ID wajib diisi di file .aldy untuk keamanan!\")\n        print(\"Bot tidak akan berjalan tanpa konfigurasi grup target yang jelas.\")\n        return None, None, timezone, None\n    \n    # Set ElevenLabs API key global\n    global ELEVENLABS_API_KEY\n    ELEVENLABS_API_KEY = elevenlabs_key\n    \n    # Validasi TIMEZONE\n    try:\n        pytz.timezone(timezone)\n    except pytz.exceptions.UnknownTimeZoneError:\n        print(f\"‚ùå TIMEZONE tidak valid: {timezone}, menggunakan Asia/Jakarta\")\n        timezone = \"Asia/Jakarta\"\n    \n    return bot_token, chat_id, timezone, elevenlabs_key\n\ndef create_config_template():\n    \"\"\"\n    Fungsi untuk membuat template file .aldy jika belum ada\n    \"\"\"\n    if not os.path.exists('.aldy'):\n        template_content = \"\"\"# Konfigurasi Bot Telegram Absensi Harian\n# ===========================================\n# \n# Petunjuk Pengisian:\n# 1. BOT_TOKEN: Dapatkan dari @BotFather di Telegram\n# 2. CHAT_ID: ID grup/channel tempat bot mengirim pesan \n# 3. TIMEZONE: Zona waktu untuk scheduler (default: Asia/Jakarta)\n\n# Token Bot Telegram (wajib diisi)\nBOT_TOKEN=your_bot_token_here\n\n# Chat ID grup/channel target (wajib diisi)  \nCHAT_ID=@vipdyy011\n\n# Timezone untuk scheduler absensi\nTIMEZONE=Asia/Jakarta\"\"\"\n        \n        try:\n            with open('.aldy', 'w', encoding='utf-8') as f:\n                f.write(template_content)\n            print(\"‚úÖ Template file .aldy berhasil dibuat\")\n            print(\"üìù Silakan edit file .aldy dan isi dengan konfigurasi yang benar\")\n        except Exception as e:\n            print(f\"‚ùå Gagal membuat template .aldy: {e}\")\n    else:\n        print(\"‚ÑπÔ∏è File .aldy sudah ada\")\n\n# Placeholder untuk konfigurasi - akan diload di main()\nBOT_TOKEN = None\nCHAT_ID = None\nTIMEZONE = \"Asia/Jakarta\"\n\n# Authorization constants\nAUTHORIZED_USER_ID = 6141653876  # Only this user ID can interact with bot\n\n# Dictionary untuk menyimpan data absensi\n# Format: {tanggal: {user_id: {\"nama\": str, \"status\": \"Hadir\"/\"Tidak Hadir\", \"waktu\": datetime}}}\nattendance = {}\n\n# Authorization helper function\nasync def check_authorization(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Check if user is authorized to use bot features\"\"\"\n    # Allow messages from target channel/group (for scheduled attendance, video collection, etc)\n    if update.effective_chat and CHAT_ID:\n        # Check if message is from target channel/group\n        if isinstance(CHAT_ID, int) and update.effective_chat.id == CHAT_ID:\n            return True\n        elif isinstance(CHAT_ID, str) and CHAT_ID.startswith('@'):\n            if update.effective_chat.username and f\"@{update.effective_chat.username}\".lower() == CHAT_ID.lower():\n                return True\n        elif str(update.effective_chat.id) == str(CHAT_ID):\n            return True\n    \n    # Allow authorized user ID\n    if update.effective_user and update.effective_user.id == AUTHORIZED_USER_ID:\n        return True\n    \n    # Unauthorized - send friendly voice response\n    if update.effective_user:\n        unauthorized_text = (\n            f\"Maaf sayang, bot ini khusus untuk owner saja ya. \"\n            f\"Bot absensi pribadi yang tidak bisa diakses user lain. \"\n            f\"Terima kasih sudah coba, tapi akses dibatasi untuk keamanan. \"\n            f\"Have a nice day!\"\n        )\n        \n        # Send unauthorized message (will auto-delete in 7 seconds)\n        await send_ephemeral_voice_with_fallback(update, context, unauthorized_text)\n        print(f\"üö´ Unauthorized access attempt from user {update.effective_user.id} ({update.effective_user.first_name})\")\n    \n    return False\n\n# Keyword untuk deteksi permintaan video\nvideo_keywords = [\n    \"video\", \"kirim\", \"kirim video\", \"minta video\", \"ada video\", \"pap video\", \n    \"narin mana videonya\", \"kirim pap\", \"videonya mana\", \"show video\",\n    \"vid\", \"vids\", \"random video\", \"video random\"\n]\n\n\nasync def video_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk menerima video dari user - langsung forward ke grup\"\"\"\n    global video_file_ids  # Global declaration harus di awal\n    \n    if not update.message or not update.message.video:\n        return\n    \n    # CRITICAL SECURITY: Authorization check for video uploads\n    if not await check_authorization(update, context):\n        return\n    \n    # VIDEO TIDAK DIHAPUS - Video messages are EXCLUDED from auto-delete\n    print(f\"üé¨ Video message received - will NOT be auto-deleted\")\n    \n    # Guard: Cegah infinite loop forwarding dari target chat sendiri\n    source_chat = update.effective_chat\n    source_user = update.effective_user\n    video = update.message.video\n    \n    # Check apakah video berasal dari target chat (ID numerik atau username)\n    is_target_chat = False\n    if source_chat:\n        # Cek berdasarkan ID numerik\n        if isinstance(CHAT_ID, int) and source_chat.id == CHAT_ID:\n            is_target_chat = True\n        # Cek berdasarkan username (dengan normalisasi case)\n        elif isinstance(CHAT_ID, str) and CHAT_ID.startswith('@'):\n            if source_chat.username and f\"@{source_chat.username}\".lower() == CHAT_ID.lower():\n                is_target_chat = True\n        # Cek berdasarkan string ID\n        elif str(source_chat.id) == str(CHAT_ID):\n            is_target_chat = True\n    \n    # Check apakah dari bot sendiri atau bot lain\n    is_from_bot = False\n    if source_user and source_user.is_bot:\n        is_from_bot = True\n    elif update.message.sender_chat and isinstance(CHAT_ID, int):\n        # Channel posts menggunakan sender_chat\n        if update.message.sender_chat.id == CHAT_ID:\n            is_from_bot = True\n    \n    # Jika dari target chat atau bot, tetap collect file_id tapi skip forwarding\n    if is_target_chat or is_from_bot:\n        # Tetap simpan file_id untuk random video meskipun skip forwarding\n        video_file_ids.append(video.file_id)\n        if len(video_file_ids) > 50:\n            video_file_ids.pop(0)\n        \n        source_info = f\"chat {source_chat.id}\" if source_chat else \"unknown\"\n        if is_from_bot:\n            source_info += \" (bot)\"\n        print(f\"üõ°Ô∏è Mencegah forward loop dari {source_info}, tapi file_id tetap disimpan\")\n        return\n    \n    try:\n        user = update.message.from_user\n        user_name = user.first_name if user else \"Unknown\"\n        \n        # Escape HTML untuk keamanan\n        safe_user_name = html.escape(user_name)\n        \n        # Kirim konfirmasi ke user dengan voice response (voice akan auto-delete)\n        voice_text = f\"Video berhasil dikirim ke grup! Durasi {video.duration} detik. Ketik kata video untuk minta video random ya sayang.\"\n        await send_ephemeral_voice_with_fallback(update, context, voice_text)\n        \n        # Langsung forward video ke grup target\n        if CHAT_ID:\n            try:\n                # Forward video asli\n                await context.bot.forward_message(\n                    chat_id=CHAT_ID,\n                    from_chat_id=update.message.chat_id,\n                    message_id=update.message.message_id\n                )\n                \n                # Simpan file_id untuk random video (max 50 video)\n                video_file_ids.append(video.file_id)\n                if len(video_file_ids) > 50:\n                    video_file_ids.pop(0)  # Hapus yang terlama\n                \n                # Kirim caption info terpisah\n                timestamp = datetime.now(pytz.timezone(TIMEZONE)).strftime(\"%Y-%m-%d %H:%M:%S\")\n                caption = f\"üé¨ <b>Video dari {safe_user_name}</b>\\n\\n\"\n                caption += f\"üìÖ {timestamp} WIB\\n\"\n                caption += f\"‚è±Ô∏è Durasi: {video.duration}s\\n\"\n                caption += f\"üìä Total koleksi: {len(video_file_ids)} video\\n\\n\"\n                caption += f\"üí° Ketik 'video' untuk video random!\"\n                \n                await context.bot.send_message(\n                    chat_id=CHAT_ID,\n                    text=caption,\n                    parse_mode='HTML'\n                )\n                \n                print(f\"‚úÖ Video dari {user_name} berhasil dikirim ke grup {CHAT_ID}\")\n                \n            except Exception as e:\n                print(f\"‚ùå Error mengirim video ke grup: {e}\")\n                voice_text = \"Maaf sayang, gagal mengirim ke grup. Pastikan bot sudah di-invite dan punya akses admin ya.\"\n                await send_ephemeral_voice_with_fallback(update, context, voice_text)\n        else:\n            voice_text = \"Grup target belum dikonfigurasi sayang.\"\n            await send_ephemeral_voice_with_fallback(update, context, voice_text)\n        \n    except Exception as e:\n        print(f\"‚ùå Error processing video: {e}\")\n        voice_text = \"Maaf sayang, ada error saat memproses video. Coba lagi ya!\"\n        await send_ephemeral_voice_with_fallback(update, context, voice_text)\n\nasync def send_random_video(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Kirim video random dari grup\"\"\"\n    try:\n        if not CHAT_ID:\n            if update.message:\n                voice_text = \"Grup target belum dikonfigurasi sayang!\"\n                await send_ephemeral_voice_with_fallback(update, context, voice_text)\n            return\n        \n        # Ambil video random dari memory storage\n        \n        if not video_file_ids:\n            if update.message:\n                voice_text = \"Belum ada video di koleksi nih sayang! Kirim video dulu ya, nanti aku bisa kirim random.\"\n                await send_ephemeral_voice_with_fallback(update, context, voice_text)\n            return\n        \n        # Pilih file_id random dan kirim\n        random_file_id = random.choice(video_file_ids)\n        \n        if update.message:\n            try:\n                await update.message.reply_video(\n                    video=random_file_id,\n                    caption=f\"üé¨ <b>Video Random!</b>\\n\\n\"\n                            f\"üìä Dari {len(video_file_ids)} video tersimpan\",\n                    parse_mode='HTML'\n                )\n                print(f\"‚úÖ Video random berhasil dikirim\")\n                \n                # Add voice confirmation for successful random video send\n                voice_text = f\"Nih sayang, video random dari koleksi! Ada {len(video_file_ids)} video tersimpan lho. Gimana, suka gak?\"\n                await send_ephemeral_voice_with_fallback(update, context, voice_text)\n            except Exception as send_error:\n                print(f\"‚ùå Error mengirim video random: {send_error}\")\n                voice_text = \"Video tidak bisa dikirim sayang, mungkin sudah expired. Kirim video baru ya!\"\n                await send_ephemeral_voice_with_fallback(update, context, voice_text)\n        \n    except Exception as e:\n        print(f\"‚ùå Error mengirim video random: {e}\")\n        if update.message:\n            voice_text = \"Ada error saat mengirim video. Coba lagi ya sayang!\"\n            await send_ephemeral_voice_with_fallback(update, context, voice_text)\n\ndef create_attendance_message():\n    \"\"\"Membuat pesan absensi dengan tombol interaktif\"\"\"\n    # Dapatkan tanggal hari ini dalam timezone yang ditentukan\n    tz = pytz.timezone(TIMEZONE)\n    today = datetime.now(tz)\n    date_str = today.strftime(\"%Y-%m-%d\")\n    \n    # Inisialisasi data absensi untuk hari ini\n    if date_str not in attendance:\n        attendance[date_str] = {}\n    \n    # Buat tombol interaktif\n    keyboard = [\n        [InlineKeyboardButton(\"‚úÖ Hadir\", callback_data=f\"hadir|{date_str}\")],\n        [InlineKeyboardButton(\"‚ùå Tidak hadir\", callback_data=f\"tidak|{date_str}\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    \n    # Pesan absensi dengan greeting berdasarkan waktu\n    current_hour = today.hour\n    if current_hour < 12:\n        greeting = \"Bangun sayang! ‚òÄÔ∏è\"\n        message = \"Sudah waktunya kerja nih, jangan ketiduran lagi ya üíï\"\n    elif current_hour < 15:\n        greeting = \"Hai sayang! üå§Ô∏è\"\n        message = \"Lagi istirahat siang ya? Jangan lupa absen dulu üòä\"\n    elif current_hour < 18:\n        greeting = \"Sore sayang! üåÖ\"\n        message = \"Masih semangat kerja kan? Absen dulu yuk üí™\"\n    else:\n        greeting = \"Malam sayang! üåô\"\n        message = \"Masih lembur nih? Jangan lupa absen ya ü•∫\"\n    \n    text = f\"{greeting}\\n\\n\"\n    text += f\"Hari {today.strftime('%A, %d %B %Y')}\\n\"\n    text += f\"Jam {today.strftime('%H:%M')} WIB\\n\\n\"\n    text += f\"{message}\\n\\n\"\n    text += f\"Pilih statusmu ya sayang:\"\n    \n    return text, reply_markup, date_str\n\nasync def validate_channel_access(context: ContextTypes.DEFAULT_TYPE, chat_id):\n    \"\"\"Validasi apakah bot dapat mengakses dan mengirim pesan ke channel\"\"\"\n    try:\n        # Coba mendapatkan informasi chat untuk memvalidasi akses\n        chat_info = await context.bot.get_chat(chat_id)\n        \n        # Cek status bot di channel\n        bot_member = await context.bot.get_chat_member(chat_id, context.bot.id)\n        \n        # Validasi permissions\n        if bot_member.status in ['administrator', 'member']:\n            # Untuk channel, bot harus admin untuk bisa kirim pesan\n            if chat_info.type == 'channel' and bot_member.status != 'administrator':\n                return False, f\"Bot bukan admin di channel {chat_info.title}\"\n            \n            return True, f\"‚úÖ Bot dapat mengakses {chat_info.type}: {chat_info.title}\"\n        else:\n            return False, f\"Bot tidak memiliki akses ke {chat_info.title}\"\n            \n    except Exception as e:\n        return False, f\"‚ùå Tidak dapat mengakses channel: {e}\"\n\nasync def send_attendance_message(context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Mengirim pesan absensi harian dengan tombol interaktif (untuk scheduler)\"\"\"\n    try:\n        text, reply_markup, date_str = create_attendance_message()\n        \n        # Kirim pesan ke chat/grup\n        if CHAT_ID:\n            # Validasi akses channel terlebih dahulu\n            can_access, message = await validate_channel_access(context, CHAT_ID)\n            if not can_access:\n                print(f\"‚ùå Gagal validasi channel: {message}\")\n                return\n            \n            await context.bot.send_message(\n                chat_id=CHAT_ID, \n                text=text, \n                reply_markup=reply_markup,\n                parse_mode='HTML'\n            )\n        \n        print(f\"‚úÖ Pesan absensi otomatis berhasil dikirim untuk tanggal {date_str}\")\n        \n    except Exception as e:\n        print(f\"‚ùå Error mengirim pesan absensi otomatis: {e}\")\n        if \"Forbidden\" in str(e):\n            print(\"üí° Pastikan bot sudah ditambahkan sebagai admin di channel target\")\n        elif \"Chat not found\" in str(e):\n            print(\"üí° Pastikan channel ID/username benar dan bot sudah di-invite ke channel\")\n\nasync def absen_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk command /absen - mengirim pesan absensi manual\"\"\"\n    if not update.message:\n        return\n    \n    # Authorization check\n    if not await check_authorization(update, context):\n        return\n    \n    # AUTO-DELETE: Schedule command message untuk dihapus dalam 7 detik\n    await schedule_message_deletion(context, update.message)\n    \n    try:\n        text, reply_markup, date_str = create_attendance_message()\n        \n        # Pesan absensi dengan tombol - TIDAK dihapus karena perlu untuk interaksi\n        await update.message.reply_text(\n            text=text,\n            reply_markup=reply_markup,\n            parse_mode='HTML'\n        )\n        \n        user_name = \"Unknown\"\n        if update.message.from_user and update.message.from_user.first_name:\n            user_name = update.message.from_user.first_name\n        print(f\"‚úÖ Pesan absensi manual berhasil dikirim oleh {user_name} untuk {date_str}\")\n        \n    except Exception as e:\n        print(f\"‚ùå Error mengirim pesan absensi manual: {e}\")\n        voice_text = \"Aduh sayang, lagi ada gangguan nih. Coba lagi nanti ya!\"\n        await send_ephemeral_voice_with_fallback(update, context, voice_text)\n\nasync def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk tombol absensi\"\"\"\n    query = update.callback_query\n    if not query:\n        return\n    \n    # Authorization check\n    if not await check_authorization(update, context):\n        return\n    \n    try:\n        # Parse data dari callback\n        if not query.data:\n            return\n        status, date_str = query.data.split(\"|\")\n        user = query.from_user\n        user_name = user.first_name\n        if user.last_name:\n            user_name += f\" {user.last_name}\"\n        \n        # Pastikan data absensi untuk tanggal tersebut ada\n        if date_str not in attendance:\n            attendance[date_str] = {}\n        \n        # Cek apakah user sudah pernah absen hari ini\n        tz = pytz.timezone(TIMEZONE)\n        current_time = datetime.now(tz)\n        status_text = \"Hadir\" if status == \"hadir\" else \"Tidak Hadir\"\n        status_emoji = \"‚úÖ\" if status == \"hadir\" else \"‚ùå\"\n        \n        # Jika sudah pernah absen, tampilkan peringatan\n        if user.id in attendance[date_str]:\n            previous_status = attendance[date_str][user.id][\"status\"]\n            previous_time = attendance[date_str][user.id][\"waktu\"].strftime('%H:%M:%S')\n            \n            if previous_status == status_text:\n                # Status sama dengan sebelumnya\n                await query.answer(f\"Sayang, kamu udah absen {status_text} tadi jam {previous_time} kok\")\n                voice_text = f\"Hai sayang! Kamu sudah absen {status_text} hari ini jam {previous_time}. Ga perlu absen lagi ya, sudah tercatat dengan baik.\"\n            else:\n                # Status berbeda, update data\n                attendance[date_str][user.id] = {\n                    \"nama\": user_name,\n                    \"status\": status_text,\n                    \"waktu\": current_time\n                }\n                \n                await query.answer(f\"Oke sayang, statusmu sudah diubah dari {previous_status} ke {status_text}\")\n                voice_text = f\"Status absensi diupdate sayang! Status kamu berubah dari {previous_status} ke {status_text} jam {current_time.strftime('%H:%M:%S')}. Sudah aku catat dengan benar ya sayang.\"\n        else:\n            # Belum pernah absen, catat absensi baru\n            attendance[date_str][user.id] = {\n                \"nama\": user_name,\n                \"status\": status_text,\n                \"waktu\": current_time\n            }\n            \n            # Answer callback dengan notifikasi singkat (muncul di popup)\n            popup_msg = f\"Alhamdulillah, absensi {status_text} sudah tercatat sayang üíï\"\n            await query.answer(popup_msg)\n            \n            # Kirim voice konfirmasi \n            if status == \"hadir\":\n                voice_text = f\"Yeay! Absensi {user_name} status {status_text} sudah tercatat jam {current_time.strftime('%H:%M:%S')}. Semangat kerja hari ini ya sayang! Jangan lupa makan dan minum yang cukup.\"\n            else:\n                voice_text = f\"Oke sayang, absensi {user_name} status {status_text} sudah aku catat jam {current_time.strftime('%H:%M:%S')}. Gapapa sayang, istirahat yang cukup ya. Semoga besok bisa kerja lagi.\"\n        \n        # Kirim voice response untuk konfirmasi absensi dengan fallback\n        if query.message:\n            # Create a fake update object for the voice helper to work with callback queries\n            fake_update = type('FakeUpdate', (), {\n                'effective_chat': query.message.chat,\n                'callback_query': query,\n                'message': None\n            })()\n            \n            await send_ephemeral_voice_with_fallback(fake_update, context, voice_text)\n        \n        print(f\"‚úÖ Absensi {user_name} ({status_text}) berhasil dicatat untuk {date_str}\")\n        \n    except Exception as e:\n        print(f\"‚ùå Error memproses tombol absensi: {e}\")\n        await query.answer(\"Aduh sayang, ada error nih\")\n        if query.message:\n            voice_text = \"Maaf sayang, ada masalah teknis nih. Coba lagi ya!\"\n            # Create a fake update object for the voice helper to work with callback queries\n            fake_update = type('FakeUpdate', (), {\n                'effective_chat': query.message.chat,\n                'callback_query': query,\n                'message': None\n            })()\n            \n            await send_ephemeral_voice_with_fallback(fake_update, context, voice_text)\n\nasync def rekap_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk command /rekap - menampilkan rekap absensi hari ini\"\"\"\n    if not update.message:\n        return\n    \n    # Authorization check\n    if not await check_authorization(update, context):\n        return\n    \n    # AUTO-DELETE: Schedule command message untuk dihapus dalam 7 detik\n    await schedule_message_deletion(context, update.message)\n    \n    try:\n        # Dapatkan tanggal hari ini\n        tz = pytz.timezone(TIMEZONE)\n        today = datetime.now(tz)\n        date_str = today.strftime(\"%Y-%m-%d\")\n        \n        # Cek apakah ada data absensi untuk hari ini\n        data = attendance.get(date_str, {})\n        \n        if not data:\n            no_data_text = (\n                f\"üìä <b>Rekap Absensi {today.strftime('%d/%m/%Y')}</b>\\n\\n\"\n                f\"Belum ada absensi hari ini sayang ü•∫\\n\"\n                f\"Mungkin lagi sibuk banget ya? Jangan lupa absen ya kalau sudah bangun üòä\"\n            )\n            # Rekap message stays PERMANENT (no auto-delete)\n            await update.message.reply_text(no_data_text, parse_mode='HTML')\n            return\n        \n        # Kelompokkan berdasarkan status\n        hadir = []\n        tidak_hadir = []\n        \n        for user_id, info in data.items():\n            nama = info[\"nama\"]\n            waktu_obj = info[\"waktu\"]\n            hari = waktu_obj.strftime(\"%A\")\n            tanggal = waktu_obj.strftime(\"%d/%m/%Y\")\n            waktu = waktu_obj.strftime(\"%H:%M:%S\")\n            \n            if info[\"status\"] == \"Hadir\":\n                hadir.append(f\"‚Ä¢ {nama}\\n  {hari}, {tanggal} - {waktu} WIB\")\n            else:\n                tidak_hadir.append(f\"‚Ä¢ {nama}\\n  {hari}, {tanggal} - {waktu} WIB\")\n        \n        # Buat pesan rekap\n        rekap_text = f\"üìä <b>Rekap Absensi Sayang</b> üíï\\n\"\n        rekap_text += f\"Hari {today.strftime('%A, %d %B %Y')}\\n\\n\"\n        \n        if hadir:\n            rekap_text += f\"üü¢ <b>Hari ini kamu kerja:</b>\\n\"\n            rekap_text += \"\\n\".join(hadir) + \"\\n\"\n            rekap_text += f\"üí™ <i>Keren banget! Tetap semangat ya</i>\"\n        \n        if tidak_hadir:\n            if hadir:\n                rekap_text += f\"\\n\\n\"\n            rekap_text += f\"üî¥ <b>Hari ini kamu libur/sakit:</b>\\n\"\n            rekap_text += \"\\n\".join(tidak_hadir) + \"\\n\"\n            rekap_text += f\"üòå <i>Istirahat yang cukup ya sayang</i>\"\n        \n        if not hadir and not tidak_hadir:\n            rekap_text += f\"Belum ada absensi hari ini\"\n        else:\n            rekap_text += f\"\\n\\nüíù <b>Total absensi:</b> {len(data)} kali hari ini\"\n        \n        # Selalu kirim rekap ke channel target (@dyyabsen)\n        if CHAT_ID:\n            # Validasi akses channel terlebih dahulu\n            can_access, access_message = await validate_channel_access(context, CHAT_ID)\n            if not can_access:\n                print(f\"‚ùå Gagal kirim rekap: {access_message}\")\n                error_text = \"Maaf sayang, ada masalah koneksi ke channel. Coba lagi nanti ya ü•∫\"\n                # Rekap error message stays PERMANENT (no auto-delete)\n                await update.message.reply_text(error_text)\n                return\n            \n            await context.bot.send_message(\n                chat_id=CHAT_ID,\n                text=rekap_text,\n                parse_mode='HTML'\n            )\n            \n            # Beri konfirmasi ke user yang meminta jika bukan di channel target\n            if update.message.chat.id != CHAT_ID:\n                confirmation_text = \"Sudah aku kirim rekapnya ke channel sayang! üíï\"\n                # Rekap confirmation stays PERMANENT (no auto-delete)\n                await update.message.reply_text(confirmation_text)\n        \n        print(f\"‚úÖ Rekap absensi berhasil dikirim untuk {date_str}\")\n        \n    except Exception as e:\n        print(f\"‚ùå Error menampilkan rekap: {e}\")\n        if \"Forbidden\" in str(e):\n            print(\"üí° Pastikan bot sudah ditambahkan sebagai admin di channel target\")\n        elif \"Chat not found\" in str(e):\n            print(\"üí° Pastikan channel ID/username benar dan bot sudah di-invite ke channel\")\n        \n        error_text = \"Aduh sayang, lagi ada gangguan nih. Coba lagi nanti ya ü•∫\"\n        await send_ephemeral_text(update, context, error_text)\n\nasync def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk membaca pesan biasa di channel/grup\"\"\"\n    if not update.message:\n        return\n    \n    message_text = update.message.text or \"\"\n    user_name = \"Unknown\"\n    \n    if update.message.from_user and update.message.from_user.first_name:\n        user_name = update.message.from_user.first_name\n    \n    # AUTO-DELETE: Schedule user text message untuk dihapus dalam 7 detik\n    if message_text and not update.message.video:  # Hanya text, BUKAN video\n        await schedule_message_deletion(context, update.message)\n    \n    message_lower = message_text.lower()\n    \n    # Deteksi kata kunci \"narin\" untuk start handler\n    if \"narin\" in message_lower:\n        print(f\"üí¨ Kata kunci 'narin' terdeteksi dari {user_name}: {message_text[:50]}...\")\n        if not await check_authorization(update, context):\n            return\n        await start_handler(update, context)\n        return\n    \n    # Deteksi kata kunci \"absen\" untuk absen handler  \n    if \"absen\" in message_lower:\n        print(f\"‚úÖ Kata kunci 'absen' terdeteksi dari {user_name}: {message_text[:50]}...\")\n        if not await check_authorization(update, context):\n            return\n        await absen_handler(update, context)\n        return\n    \n    # Deteksi kata kunci \"rekap\" untuk rekap handler\n    if \"rekap\" in message_lower:\n        print(f\"üìä Kata kunci 'rekap' terdeteksi dari {user_name}: {message_text[:50]}...\")\n        if not await check_authorization(update, context):\n            return\n        await rekap_handler(update, context)\n        return\n    \n    # Deteksi kata kunci quota dengan variasi natural\n    quota_keywords = [\"uang\", \"pulsa\", \"sisa\", \"duit\", \"kredit\", \"credit\", \"quota\", \"balance\"]\n    is_quota_request = any(keyword in message_lower for keyword in quota_keywords)\n    \n    if is_quota_request:\n        print(f\"üí∞ Kata kunci quota terdeteksi dari {user_name}: {message_text[:50]}...\")\n        if not await check_authorization(update, context):\n            return\n        await quota_handler(update, context)\n        return\n    \n    # Deteksi kata kunci video untuk semua chat (tidak hanya channel target)\n    is_video_request = any(keyword.lower() in message_lower for keyword in video_keywords)\n    \n    if is_video_request:\n        print(f\"üé¨ Permintaan video dari {user_name}: {message_text[:50]}...\")\n        # Authorization check for video requests\n        if not await check_authorization(update, context):\n            return\n        await send_random_video(update, context)\n        return\n        \n    # Hanya proses pesan dari channel target untuk logging\n    if (isinstance(CHAT_ID, str) and CHAT_ID.startswith('@') and \n        update.message.chat.username == CHAT_ID.replace('@', '')):\n        print(f\"üì© Pesan diterima dari {user_name} di channel: {message_text[:50]}...\")\n        \n        # Bot bisa ditambahkan fitur auto-response di sini jika diperlukan\n        # Misalnya jika ada kata kunci tertentu, bot otomatis kasih respons\n\nasync def test_channel_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk command /test_channel - test koneksi ke channel target\"\"\"\n    if not update.message:\n        return\n    \n    # Authorization check\n    if not await check_authorization(update, context):\n        return\n    \n    # AUTO-DELETE: Schedule command message untuk dihapus dalam 7 detik\n    await schedule_message_deletion(context, update.message)\n    \n    try:\n        if not CHAT_ID:\n            voice_text = \"Channel belum dikonfigurasi sayang. Silakan set CHAT_ID di file .env terlebih dahulu ya.\"\n            await send_ephemeral_voice_with_fallback(update, context, voice_text)\n            return\n        \n        # Test koneksi ke channel\n        can_access, message = await validate_channel_access(context, CHAT_ID)\n        \n        if can_access:\n            # Kirim pesan test ke channel\n            test_message = (\n                \"üîß <b>Test Koneksi Channel</b>\\n\\n\"\n                \"‚úÖ Bot berhasil terhubung dan dapat mengirim pesan ke channel ini!\\n\"\n                f\"üìÖ Waktu test: {datetime.now(pytz.timezone(TIMEZONE)).strftime('%d/%m/%Y %H:%M:%S')} WIB\"\n            )\n            \n            await context.bot.send_message(\n                chat_id=CHAT_ID,\n                text=test_message,\n                parse_mode='HTML'\n            )\n            \n            voice_text = f\"Test Channel Berhasil sayang! {message}. Target channel {CHAT_ID}. Pesan test sudah dikirim ke channel.\"\n            await send_ephemeral_voice_with_fallback(update, context, voice_text)\n        else:\n            voice_text = f\"Test Channel Gagal sayang! {message}. Target channel {CHAT_ID}. Solusinya: Pastikan bot sudah di-invite ke channel, pastikan bot memiliki hak admin, dan periksa kembali CHAT_ID di .env.\"\n            await send_ephemeral_voice_with_fallback(update, context, voice_text)\n            \n    except Exception as e:\n        print(f\"‚ùå Error test channel: {e}\")\n        voice_text = f\"Error saat test channel sayang. Detail error: {str(e)}. Silakan periksa konfigurasi dan coba lagi ya.\"\n        await send_ephemeral_voice_with_fallback(update, context, voice_text)\n\nasync def list_videos_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk command /videos - info video di grup\"\"\"\n    if not update.message:\n        return\n    \n    # Authorization check\n    if not await check_authorization(update, context):\n        return\n    \n    # AUTO-DELETE: Schedule command message untuk dihapus dalam 7 detik\n    await schedule_message_deletion(context, update.message)\n    \n    try:\n        if not CHAT_ID:\n            voice_text = \"Grup belum dikonfigurasi sayang. Silakan set CHAT_ID terlebih dahulu ya.\"\n            await send_ephemeral_voice_with_fallback(update, context, voice_text)\n            return\n        \n        voice_text = f\"Info Video sayang! Video disimpan di grup {CHAT_ID}. Cara kerjanya: Kirim video ke bot, otomatis masuk grup. Ketik video, bot kasih video random. Cek grup langsung untuk lihat semua video. Status: {len(video_file_ids)} video di koleksi. Tips: Video tersimpan aman tanpa memakan storage!\"\n        await send_ephemeral_voice_with_fallback(update, context, voice_text)\n        \n    except Exception as e:\n        print(f\"‚ùå Error menampilkan info video: {e}\")\n        voice_text = \"Ada error saat menampilkan info. Coba lagi ya sayang!\"\n        await send_ephemeral_voice_with_fallback(update, context, voice_text)\n\nasync def start_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk command /start\"\"\"\n    if not update.message:\n        return\n    \n    # Authorization check\n    if not await check_authorization(update, context):\n        return\n    \n    # AUTO-DELETE: Schedule command message untuk dihapus dalam 7 detik\n    await schedule_message_deletion(context, update.message)\n    \n    voice_text = (\n        \"Hai sayang, aku Narin. \"\n        \"Aku siap bantu kamu setiap hari. \"\n        \"Ketik 'absen' untuk kerja, 'rekap' untuk lihat aktivitas, \"\n        \"atau 'video' kalau kangen. \"\n        \"Love you sayang!\"\n    )\n    \n    await send_ephemeral_voice_with_fallback(update, context, voice_text)\n\nasync def suara_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk command /suara - test voice response\"\"\"\n    if not update.message:\n        return\n    \n    # Authorization check\n    if not await check_authorization(update, context):\n        return\n    \n    # AUTO-DELETE: Schedule command message untuk dihapus dalam 7 detik\n    await schedule_message_deletion(context, update.message)\n    \n    if not context.args:\n        voice_text = \"Command suara sayang! Cara pakainya: slash suara lalu tulis text yang mau diubah jadi suara. Bot akan mengubah text menjadi suara!\"\n        await send_ephemeral_voice_with_fallback(update, context, voice_text)\n        return\n    \n    # Gabungkan semua argument menjadi text\n    text_to_speak = ' '.join(context.args)\n    \n    # Batasi panjang text (max 200 karakter)\n    if len(text_to_speak) > 200:\n        voice_text = \"Text terlalu panjang sayang! Maksimal 200 karakter ya.\"\n        await send_ephemeral_voice_with_fallback(update, context, voice_text)\n        return\n    \n    # Kirim voice response dengan fallback otomatis\n    await send_ephemeral_voice_with_fallback(update, context, text_to_speak, \"Gagal membuat voice message sayang. Coba lagi ya!\")\n\nasync def speak_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk command /speak - alias untuk /suara\"\"\"\n    await suara_handler(update, context)\n\nasync def demo_voice_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk demo voice message\"\"\"\n    if not update.message:\n        return\n    \n    # Authorization check\n    if not await check_authorization(update, context):\n        return\n    \n    # AUTO-DELETE: Schedule command message untuk dihapus dalam 7 detik\n    await schedule_message_deletion(context, update.message)\n    \n    demo_text = \"Halo! Ini adalah demo fitur suara dari bot absensi. Aku bisa mengubah text menjadi suara dengan natural!\"\n    \n    # Demo voice dengan fallback otomatis\n    await send_ephemeral_voice_with_fallback(update, context, demo_text, \"Demo voice tidak bisa dijalankan saat ini sayang.\")\n\nasync def bantu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk command /bantu - menampilkan daftar kata kunci yang tersedia\"\"\"\n    if not update.message:\n        return\n    \n    # Authorization check\n    if not await check_authorization(update, context):\n        return\n    \n    # AUTO-DELETE: Schedule command message untuk dihapus dalam 7 detik\n    await schedule_message_deletion(context, update.message)\n    \n    # Daftar kata kunci yang tersedia\n    help_text = (\n        \"ü§ñ <b>Daftar Kata Kunci Bot Asisten</b>\\n\\n\"\n        \"üí¨ <b>Kata Kunci Utama:</b>\\n\"\n        \"üîπ <code>narin</code> - Tutorial & info bot\\n\"\n        \"   <i>Contoh: \\\"Halo Narin\\\", \\\"Apa kabar Narin?\\\"</i>\\n\\n\"\n        \"üîπ <code>absen</code> - Form absensi harian\\n\"\n        \"   <i>Contoh: \\\"Saya mau absen nih\\\", \\\"Waktunya absen\\\"</i>\\n\\n\"\n        \"üîπ <code>rekap</code> - Rekap absensi hari ini\\n\"\n        \"   <i>Contoh: \\\"Sayang rekap dong\\\", \\\"Cek rekap\\\"</i>\\n\\n\"\n        \"üîπ <code>uang</code>, <code>pulsa</code>, <code>sisa</code> - Cek sisa credit ElevenLabs\\n\"\n        \"   <i>Contoh: \\\"Uang kamu sisa berapa?\\\", \\\"Pulsa masih ada?\\\", \\\"Cek sisa\\\"</i>\\n\\n\"\n        \"üé¨ <b>Kata Kunci Video:</b>\\n\"\n        \"üîπ <code>video</code> - Video random dari koleksi\\n\"\n        \"üîπ <code>kirim video</code> - Minta video random\\n\"\n        \"üîπ <code>minta video</code> - Video dari koleksi\\n\\n\"\n        \"üì± <b>Command Tersisa:</b>\\n\"\n        \"üîπ <code>/suara [text]</code> - Text ke voice\\n\"\n        \"üîπ <code>/videos</code> - Info video sistem\\n\"\n        \"üîπ <code>/test_channel</code> - Test koneksi\\n\"\n        \"üîπ <code>/quota</code> - Cek sisa credit ElevenLabs\\n\\n\"\n        \"üí° <b>Tips:</b> Cukup ketik kata kunci di mana saja dalam kalimat!\\n\"\n        \"üéØ <b>Status:</b> Voice response aktif dengan ElevenLabs!\"\n    )\n    \n    # Kirim help sebagai text message yang tidak auto-delete (permanen)\n    await update.message.reply_text(\n        help_text,\n        parse_mode='HTML'\n    )\n    \n    # Konfirmasi voice\n    voice_text = \"Daftar kata kunci sudah dikirim sayang! Sekarang kamu tahu semua cara ngobrol sama aku. Coba deh ketik kata kunci yang ada!\"\n    await send_ephemeral_voice_with_fallback(update, context, voice_text)\n\nasync def quota_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handler untuk command /quota - cek sisa credit ElevenLabs\"\"\"\n    if not update.message:\n        return\n    \n    # Authorization check\n    if not await check_authorization(update, context):\n        return\n    \n    # AUTO-DELETE: Schedule command message untuk dihapus dalam 7 detik\n    await schedule_message_deletion(context, update.message)\n    \n    try:\n        # Send typing action\n        await context.bot.send_chat_action(\n            chat_id=update.effective_chat.id,\n            action=\"typing\"\n        )\n        \n        # Check quota from ElevenLabs API\n        quota_info = await check_elevenlabs_quota()\n        \n        if not quota_info:\n            voice_text = \"Maaf sayang, tidak bisa cek quota ElevenLabs. Mungkin API key tidak valid atau ada masalah koneksi.\"\n            await send_ephemeral_voice_with_fallback(update, context, voice_text)\n            return\n        \n        # Format quota information (simplified)\n        quota_text = f\"üí∞ <b>Sisa:</b> {quota_info['remaining']:,}\"\n        \n        # Kirim sebagai text message dengan auto-delete 7 detik\n        quota_message = await update.message.reply_text(\n            quota_text,\n            parse_mode='HTML'\n        )\n        \n        # AUTO-DELETE: Schedule quota message untuk dihapus dalam 7 detik\n        await schedule_message_deletion(context, quota_message)\n        \n        # Voice confirmation (simplified)\n        voice_text = f\"Sisa {quota_info['remaining']:,} sayang!\"\n        \n        await send_ephemeral_voice_with_fallback(update, context, voice_text)\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking quota: {e}\")\n        voice_text = \"Ada error saat cek quota sayang. Coba lagi nanti ya!\"\n        await send_ephemeral_voice_with_fallback(update, context, voice_text)\n\ndef setup_job_queue(application):\n    \"\"\"Setup PTB JobQueue untuk mengirim pesan absensi otomatis\"\"\"\n    try:\n        # Setup timezone\n        tz = pytz.timezone(TIMEZONE)\n        \n        # Jadwalkan pengiriman pesan absensi setiap hari jam 07:00\n        application.job_queue.run_daily(\n            send_attendance_message,\n            time=time(hour=7, minute=0, tzinfo=tz),\n            name='daily_attendance'\n        )\n        \n        print(f\"‚úÖ JobQueue berhasil diatur untuk jam 07:00 {TIMEZONE}\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error setup JobQueue: {e}\")\n        return False\n\ndef main():\n    \"\"\"Fungsi utama untuk menjalankan bot\"\"\"\n    global application, BOT_TOKEN, CHAT_ID, TIMEZONE\n    \n    # Buat template .aldy jika belum ada\n    create_config_template()\n    \n    # Load konfigurasi setelah template dibuat\n    BOT_TOKEN, CHAT_ID, TIMEZONE, ELEVENLABS_KEY = load_config()\n    \n    # Validasi konfigurasi\n    if not BOT_TOKEN:\n        print(\"Bot token belum diisi\")\n        print(\"Silakan isi BOT_TOKEN di file .env atau environment variable\")\n        return\n    \n    if not CHAT_ID:\n        print(\"Chat ID belum diisi\")\n        print(\"Silakan isi CHAT_ID di file .env atau environment variable\")\n        return\n    \n    # Inisialisasi ElevenLabs untuk voice response\n    if init_elevenlabs():\n        print(\"üé§ Bot siap dengan suara wanita ElevenLabs!\")\n    else:\n        print(\"‚ö†Ô∏è ElevenLabs tidak tersedia, voice response dinonaktifkan\")\n    \n    try:\n        # Inisialisasi aplikasi bot\n        application = ApplicationBuilder().token(BOT_TOKEN).build()\n        \n        # Tambahkan handlers\n        application.add_handler(CommandHandler(\"start\", start_handler))\n        application.add_handler(CommandHandler(\"rekap\", rekap_handler))\n        application.add_handler(CommandHandler(\"absen\", absen_handler))\n        application.add_handler(CommandHandler(\"videos\", list_videos_handler))\n        application.add_handler(CommandHandler(\"test_channel\", test_channel_handler))\n        application.add_handler(CommandHandler(\"bantu\", bantu_handler))\n        application.add_handler(CommandHandler(\"quota\", quota_handler))\n        \n        # Voice handlers\n        application.add_handler(CommandHandler(\"suara\", suara_handler))\n        application.add_handler(CommandHandler(\"speak\", speak_handler))\n        application.add_handler(CommandHandler(\"demo_voice\", demo_voice_handler))\n        application.add_handler(CallbackQueryHandler(button_handler))\n        \n        # Handler untuk video upload\n        application.add_handler(MessageHandler(filters.VIDEO, video_handler))\n        \n        # Handler untuk membaca pesan biasa di channel\n        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, message_handler))\n        \n        # Setup job queue untuk scheduler\n        setup_job_queue(application)\n        \n        print(\"Bot absensi sudah siap!\")\n        print(f\"Target Chat ID: {CHAT_ID}\")\n        print(f\"Timezone: {TIMEZONE}\")\n        print(\"Akan mengirim pesan absensi setiap jam 07:00 WIB\")\n        print(\"Ketik /rekap untuk lihat rekap absensi hari ini\")\n        print(\"Tekan Ctrl+C untuk stop\\n\")\n        \n        # Jalankan bot (sinkron, tidak dalam async)\n        application.run_polling(\n            poll_interval=1.0,\n            timeout=10,\n            bootstrap_retries=5\n        )\n        \n    except Exception as e:\n        print(f\"‚ùå Error menjalankan bot: {e}\")\n    \n    finally:\n        # Cleanup otomatis oleh PTB\n        print(\"üõë Bot dihentikan\")\n\nif __name__ == \"__main__\":\n    # Jalankan bot\n    main()","size_bytes":55260},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"apscheduler>=3.11.0\",\n    \"python-dotenv>=1.1.1\",\n    \"python-telegram-bot==20.3\",\n    \"pytz>=2025.2\",\n    \"pyttsx3>=2.90\",\n]\n","size_bytes":273},"replit.md":{"content":"# Replit.md\n\n## Overview\n\nThis is a Telegram bot designed for daily attendance tracking. The bot provides automated attendance management functionality through Telegram's messaging platform, allowing users to track their daily presence/absence status. The application uses Python with the python-telegram-bot library to handle Telegram API interactions and includes timezone support for accurate time-based operations.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Bot Framework Architecture\nThe application is built on the python-telegram-bot library (version 20.3), utilizing the modern async/await pattern with the ApplicationBuilder. The bot implements a command-based interface with callback query handling for interactive buttons and menus.\n\n### Configuration Management\nThe system uses a dual-layer configuration approach:\n- Primary: Environment variables loaded from a .env file using python-dotenv\n- Fallback: Direct system environment variables\n- Includes automatic .env template generation for easy setup\n- Configuration validation for critical parameters like CHAT_ID and TIMEZONE\n\n### Command Structure\nThe bot implements handlers for:\n- CommandHandler: For processing slash commands\n- CallbackQueryHandler: For handling inline keyboard interactions\n- Structured around attendance management workflows\n\n### Time Zone Handling\nUses pytz library for robust timezone management with Asia/Jakarta as the default timezone. Includes timezone validation to prevent configuration errors.\n\n### Error Handling and Validation\nImplements comprehensive validation for:\n- Bot token verification\n- Chat ID format validation (integer conversion)\n- Timezone string validation against pytz database\n- Graceful fallbacks for invalid configurations\n\n## External Dependencies\n\n### Telegram Bot API\n- **Service**: Telegram Bot API via python-telegram-bot library\n- **Purpose**: Core messaging platform and user interface\n- **Integration**: Direct API communication for sending/receiving messages and handling callbacks\n\n### Python Libraries\n- **python-telegram-bot (20.3)**: Main framework for Telegram bot functionality\n- **pytz (2025.2)**: Timezone handling and datetime operations\n- **python-dotenv (1.1.1)**: Environment variable management from .env files\n\n### Environment Configuration\n- **BOT_TOKEN**: Required Telegram bot authentication token\n- **CHAT_ID**: Target chat/group identifier for bot operations\n- **TIMEZONE**: Configurable timezone setting (defaults to Asia/Jakarta)","size_bytes":2541}},"version":1}